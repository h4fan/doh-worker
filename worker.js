
// Export a default object containing event handlers
export default {
  // The fetch handler is invoked when this worker receives a HTTP(S) request
  // and should return a Response (optionally wrapped in a Promise)
  async fetch(request, env, ctx) {
    // You'll find it helpful to parse the request.url string into a URL object. Learn more at https://developer.mozilla.org/en-US/docs/Web/API/URL
const doh = 'https://1.1.1.1/dns-query'
const dohjson = 'https://1.1.1.1/dns-query'

const contype = 'application/dns-message'
const jsontype = 'application/dns-json'

const osdomains = ['www.example.com.',]
const blackiplist = ['1.2.3.4',]

// this function is generated by Genai
function endsWithAny(str, suffixes) {
    // 遍历数组中的每个后缀
    for (let suffix of suffixes) {
        // 使用自定义的 endsWith 函数检查字符串是否以此后缀结束
        if (str.toLowerCase().endsWith(suffix)) {
            return true; 
        }
    }
    return false;
}

const arrayBuffer = await request.arrayBuffer();
const respArrayBuffer = new ArrayBuffer(0x3433) //arrayBuffer.byteLength is 0x3333, we need to be bigger than that

const uint8Response = new Uint8Array(respArrayBuffer);
const view = new DataView(respArrayBuffer)

uint8Response.set(new Uint8Array(arrayBuffer.slice(0, arrayBuffer.byteLength)),0) // copy the request
view.setUint16(2,0x8180) //set flag
    
let position = 12 //the position of the first question
let length = view.getUint8(position++)
let result = ""
let decoder = new TextDecoder('utf-8');

// read the first label, we didn't deal with the message compression https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4
// if you want to use it in production, you should consider message compression
// and we only deal with the first question
while (length != 0) {
    result += decoder.decode(uint8Response.slice(position, position+length))+'.';
    position += length;
    length = view.getUint8(position++);
}
// get the first domain
let curDomain = result
let curQtype = view.getUint16(position)

position += 2
position += 2

// we only deal with the matched domains and it must be a A query, otherwise justs proxy the request
if(endsWithAny(curDomain,osdomains) && (curQtype == 1)){
	let userip = request.headers.get('x-real-ip')
	let edns_ip = userip.substring(0,userip.lastIndexOf('.')) + '.0/24'
  //we use an doh provider which support edns
  let api = 'https://dns.alidns.com/resolve?name='+curDomain+'&type=1&short=1&edns_client_subnet='+edns_ip
 
	return await fetch(api)
  .then(resp => {
    // 检查响应状态
    if (resp.ok) {
      // 解析返回的 JSON 数据
      //return new Response(resp, {headers: { "Content-Type": "application/dns-message" }})
      return resp.json();
    } else {
      throw new Error(`Failed to fetch data, status: ${resp.status}`);
    }
  })
  .then(data => {
  view.setUint16(6,data.length) // set ANCOUNT 
 
	for (let item of data) {
      view.setUint16(position,0xc00c) //name
      position += 2
      view.setUint16(position,0x0001) //type
      position += 2
      view.setUint16(position,0x0001) //class
      position += 2
      view.setUint32(position,300) //ttl
      position += 4
      view.setUint16(position,4) //length(A) = 4
      position += 2
      uint8Response.set(new Uint8Array(item.split('.').map(part=>parseInt(part))) ,position) // set the resolved ip
      position += 4
		}
    return new Response(respArrayBuffer.slice(0,position), {headers: { "Content-Type": "application/dns-message" }})
  })
  .catch(error => {
    // 处理错误
    console.error(error);
  });
}
else{
  return await fetch(doh, {
            method: 'POST',
            headers: {
                'Accept': contype,
                'Content-Type': contype,
            },
            body: arrayBuffer,
        });
}
  },
};
